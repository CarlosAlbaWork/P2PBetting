{
  "language": "Solidity",
  "sources": {
    "src/P2PBetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract P2PBetting is Ownable {\n    /////////////////////////////////////////////\n    ////////// ERRORS ///////////////////////////\n    /////////////////////////////////////////////\n\n    error P2PBetting__TransferFailed();\n    error P2PBetting__NumberOfChallengersCantBeZero();\n    error P2PBetting__MaxPriceCantBeZero();\n    error P2PBetting__OddsMustBeHigherThanOne();\n    error P2PBetting__NotEnoughEthSent();\n    error P2PBetting__TooMuchEthSent();\n    error P2PBetting__BetIsFullOrNonexistent();\n    error P2PBetting__CantEnterBetNow();\n    error P2PBetting__UserNotInBet();\n    error P2PBetting__AlreadyRetrievedOrBetNonexistent();\n    error P2PBetting__OnlyCalledIfTipsterLost();\n\n    /////////////////////////////////////////////\n    ////////// EVENTS ///////////////////////////\n    /////////////////////////////////////////////\n\n    event P2PBetting__NewFeeSet(uint256 indexed oldFee, uint256 indexed newFee);\n    event P2PBetting__NewOracleSet(address indexed oracle);\n    event P2PBetting__BetCreated(\n        uint256 indexed maxPrice,\n        uint256 indexed odds,\n        uint256 indexed maxNumOfPlayers,\n        string betData\n    );\n    event P2PBetting__FeesCollected(uint256 indexed feesCollected);\n    event P2PBetting__BetJoined(\n        address indexed challenger,\n        uint256 indexed betID\n    );\n    event P2PBetting__RewardClaimed(\n        address indexed winner,\n        uint256 indexed amount\n    );\n\n    /////////////////////////////////////////////\n    ////////// VARIABLES ////////////////////////\n    /////////////////////////////////////////////\n\n    //Podría ser un array de estos, ya que puede haber EUR_ETH, ARG_ETH....\n    AggregatorV3Interface internal USD_ETH_dataFeed;\n\n    uint256 constant DECIMALS = 1000; //3 decimals\n    uint256 private s_fee; // 2000 = 2%\n    uint256 private feesCollected;\n    uint256 private numberOfBetsDone;\n\n    mapping(address user => Profile profile) s_Profiles;\n    mapping(uint256 betId => Bet bet) s_Bets;\n\n    struct Profile {\n        int256 balanceVariation;\n        uint256[] betIdHistory;\n    }\n\n    struct Bet {\n        uint256 betId;\n        address tipster;\n        uint256 collateralGiven;\n        uint256 moneyInBet;\n        uint256 maxNumberOfChallengers;\n        address[] challengers;\n        uint256[] challengersMoneyBet;\n        uint256 odds; //Por ejemplo 1500 = 1.5\n        uint256 maxEntryFee;\n        uint256 fee;\n        bool tipsterWon;\n        bool locked;\n        bool ended; //cuando el partido se acaba\n        uint256 timestampWhenEnded;\n        //Falta una variable que contenga datos de la apuesta.\n        //Cuando tengamos claro cómo funciona la IA, se podrá parametrizar\n        //Por ejemplo : \"Madrid Gana , Barça gana o empata, Manchester City más de 4,5 amarillas, más de 4.5 goles...\n    }\n\n    constructor(uint256 fee_, address owner) Ownable(owner) {\n        s_fee = fee_;\n    }\n\n    function collectFees() external {\n        (bool succ, ) = payable(owner()).call{value: feesCollected}(\"\");\n        if (!succ) {\n            revert P2PBetting__TransferFailed();\n        }\n        uint256 feesCollectedNow = feesCollected;\n        feesCollected = 0;\n        emit P2PBetting__FeesCollected(feesCollectedNow);\n    }\n\n    function createBet(\n        uint256 maxNumberOfChallengers_,\n        uint256 odds_,\n        uint256 maxEntryFee_ /** , variable de datos de la apuesta */\n    ) external payable {\n        if (odds_ <= 1000) {\n            revert P2PBetting__OddsMustBeHigherThanOne();\n        }\n        if (maxNumberOfChallengers_ == 0) {\n            revert P2PBetting__NumberOfChallengersCantBeZero();\n        }\n        if (maxEntryFee_ == 0) {\n            revert P2PBetting__MaxPriceCantBeZero();\n        }\n        if (\n            msg.value <\n            ((maxNumberOfChallengers_ * odds_ * maxEntryFee_) /\n                DECIMALS -\n                maxNumberOfChallengers_ *\n                maxEntryFee_)\n        ) {\n            revert P2PBetting__NotEnoughEthSent();\n        }\n        Bet memory newBet;\n        newBet.tipster = msg.sender;\n\n        newBet.maxNumberOfChallengers = maxNumberOfChallengers_;\n\n        newBet.odds = odds_;\n        newBet.fee = s_fee;\n\n        newBet.maxEntryFee = maxEntryFee_;\n        //newBet.variabledatosdeapuesta = datos de la apuesta\n\n        newBet.moneyInBet = msg.value;\n        newBet.collateralGiven = msg.value;\n        newBet.betId = numberOfBetsDone;\n        s_Bets[numberOfBetsDone] = newBet;\n        s_Profiles[msg.sender].betIdHistory.push(numberOfBetsDone);\n        s_Profiles[msg.sender].balanceVariation -= int256(msg.value);\n        numberOfBetsDone++;\n\n        emit P2PBetting__BetCreated(\n            maxEntryFee_,\n            odds_,\n            maxNumberOfChallengers_,\n            \"Aqui el string de los datos de la apuesta\"\n        );\n    }\n\n    function joinBet(uint256 betId_) external payable {\n        Bet memory betSelected = s_Bets[betId_];\n        if (\n            betSelected.maxNumberOfChallengers <= betSelected.challengers.length\n        ) {\n            revert P2PBetting__BetIsFullOrNonexistent();\n        }\n        if (msg.value > betSelected.maxEntryFee) {\n            revert P2PBetting__TooMuchEthSent();\n        }\n\n        if (betSelected.ended || betSelected.locked) {\n            revert P2PBetting__CantEnterBetNow();\n        }\n\n        s_Bets[betId_].challengers.push(msg.sender);\n        s_Bets[betId_].challengersMoneyBet.push(msg.value);\n        s_Bets[betId_].moneyInBet += msg.value;\n        s_Profiles[msg.sender].betIdHistory.push(betId_);\n        s_Profiles[msg.sender].balanceVariation -= int256(msg.value);\n\n        emit P2PBetting__BetJoined(msg.sender, betId_);\n    }\n\n    //Función automatizada que pide el resultado de fútbol a la api y\n    //cierra la apuesta, decidiendo si el ganador es el challenger o el tipster\n\n    //Ahora no tiene nada, solo está así para testear , cambiará en el futuro\n\n    function lockBet(uint256 betId_) external {\n        s_Bets[betId_].locked = true;\n    }\n\n    function endBet(uint256 betId_, bool tipsterWon) public {\n        //Automation\n        //functions\n\n        s_Bets[betId_].tipsterWon = tipsterWon;\n        s_Bets[betId_].ended = true;\n    }\n\n    function getRewards(uint256 betId, uint256 numberOfChallenger) external {\n        Bet memory betSelected = s_Bets[betId];\n\n        if (\n            msg.sender == betSelected.tipster &&\n            betSelected.tipsterWon &&\n            betSelected.moneyInBet != 0 &&\n            betSelected.ended\n        ) {\n            s_Profiles[msg.sender].balanceVariation += int256(\n                betSelected.moneyInBet\n            );\n            uint256 feeFromThisBet = ((betSelected.moneyInBet -\n                betSelected.collateralGiven) *\n                betSelected.odds *\n                betSelected.fee) / (100 * DECIMALS * DECIMALS); //Revisar, puede que mal\n            uint256 moneyToTransfer = betSelected.moneyInBet - feeFromThisBet;\n            s_Bets[betId].moneyInBet = 0;\n            feesCollected += feeFromThisBet;\n            payable(msg.sender).transfer(moneyToTransfer);\n            emit P2PBetting__RewardClaimed(msg.sender, moneyToTransfer);\n        } else if (\n            numberOfChallenger < betSelected.challengers.length &&\n            msg.sender == betSelected.challengers[numberOfChallenger] &&\n            betSelected.challengersMoneyBet[numberOfChallenger] != 0 &&\n            betSelected.ended &&\n            !betSelected.tipsterWon\n        ) {\n            uint256 amountWon = (betSelected.odds *\n                betSelected.challengersMoneyBet[numberOfChallenger]) / DECIMALS;\n            s_Profiles[msg.sender].balanceVariation += int256(amountWon);\n            uint256 feeFromThisBet = (amountWon * betSelected.fee) /\n                (100 * DECIMALS); //Revisar, puede que mal\n            uint256 moneyToTransfer = amountWon - feeFromThisBet;\n            s_Bets[betId].challengersMoneyBet[numberOfChallenger] = 0;\n            feesCollected += feeFromThisBet;\n            (bool succ, ) = payable(msg.sender).call{value: moneyToTransfer}(\n                \"\"\n            );\n            if (!succ) {\n                revert P2PBetting__TransferFailed();\n            }\n            emit P2PBetting__RewardClaimed(msg.sender, moneyToTransfer);\n        } else {\n            revert P2PBetting__AlreadyRetrievedOrBetNonexistent();\n        }\n    }\n\n    function getCollateralBack(uint256 betId_) external {\n        Bet memory betSelected = s_Bets[betId_];\n        if (betSelected.collateralGiven == 0 ) {\n            revert P2PBetting__AlreadyRetrievedOrBetNonexistent();\n        }\n        if (!betSelected.ended || betSelected.tipsterWon){\n            revert P2PBetting__OnlyCalledIfTipsterLost();\n        }\n        uint256 amountToTransferBack = betSelected.moneyInBet -(((betSelected.moneyInBet - betSelected.collateralGiven) * betSelected.odds)/DECIMALS);\n        s_Bets[betId_].collateralGiven = 0;\n        payable(betSelected.tipster).transfer(amountToTransferBack);\n    }\n\n    ///////////////////////////////////////////\n    /////// SETTERS ///////////////////////////\n    ///////////////////////////////////////////\n\n    function setFee(uint256 newFee) external onlyOwner {\n        uint256 oldfee = s_fee;\n        s_fee = newFee;\n        emit P2PBetting__NewFeeSet(oldfee, newFee);\n    }\n\n    function setUsdOracle(address newOracle) external onlyOwner {\n        USD_ETH_dataFeed = AggregatorV3Interface(newOracle);\n        emit P2PBetting__NewOracleSet(newOracle);\n    }\n\n    ///////////////////////////////////////////\n    /////// GETTERS ///////////////////////////\n    ///////////////////////////////////////////\n\n    function getFee() external view returns (uint256) {\n        return s_fee;\n    }\n\n    function getOracle() external view returns (address) {\n        return address(USD_ETH_dataFeed);\n    }\n\n    function getProfile(address user) external view returns (Profile memory) {\n        return s_Profiles[user];\n    }\n\n    function getBet(uint256 betId) external view returns (Bet memory) {\n        return s_Bets[betId];\n    }\n\n    function getFeesCollected() external view returns (uint256) {\n        return feesCollected;\n    }\n\n    function getNumberOfChallenger(\n        uint256 betId_\n    ) external view returns (uint256) {\n        address[] memory possibleAddresses = s_Bets[betId_].challengers;\n        for (uint i; i < possibleAddresses.length; i++) {\n            if (possibleAddresses[i] == msg.sender) {\n                return i;\n            }\n        }\n        revert P2PBetting__UserNotInBet();\n    }\n\n    function getNumberOfBets() external view returns (uint256) {\n        return numberOfBetsDone;\n    }\n\n    //Uso de Chainlink-DataStreams\n    function getUsdConversionRate(\n        uint256 usdValue_\n    ) external view returns (uint256) {\n        (, int256 answer, , , ) = USD_ETH_dataFeed.latestRoundData();\n        uint256 ethPrice = uint256(answer * 10000000000);\n        // Convertir la cantidad de USD a Ether utilizando la tasa de conversión actual\n        uint256 ethAmount = (usdValue_ * 1e18) / ethPrice;\n        return ethAmount;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "mode": "3",
      "details": null,
      "fallbackToOptimizingForSize": false,
      "disableSystemRequestMemoization": true
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "libraries": {},
    "isSystem": false,
    "forceEvmla": false,
    "areLibrariesMissing": false
  }
}