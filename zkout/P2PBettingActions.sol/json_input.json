{
  "language": "Solidity",
  "sources": {
    "src/P2PBettingActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\n\nimport \"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\";\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol\";\n\nimport {P2PBetting} from \"../src/P2PBettingFront.sol\";\n\n//Alomejor hay que importar esta:\n// import {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\n\ncontract P2PBettingActions is\n    ConfirmedOwner,\n    AutomationCompatibleInterface,\n    FunctionsClient\n{\n    using FunctionsRequest for FunctionsRequest.Request;\n    P2PBetting p2pBetting;\n\n    /////////////////////////////////////////////\n    ////////// ERRORS ///////////////////////////\n    /////////////////////////////////////////////\n\n    error P2PBetting__MatchDidNotEnd();\n\n    /////////////////////////////////////////////\n    ////////// EVENTS ///////////////////////////\n    /////////////////////////////////////////////\n\n    /////////////////////////////////////////////\n    ////////// CHAINNLINK VARIABLES /////////////\n    /////////////////////////////////////////////\n\n    // DON ID for the Functions DON to which the requests are sent\n\n    bytes32 public s_lastRequestId;\n    bytes public s_lastResponse;\n    bytes public s_lastError;\n    uint32 gasLimit = 3000000;\n\n    //Valores hardcodeados para Avalanche Fuji\n\n    address router = 0xA9d587a00A31A52Ed70D6026794a8FC5E2F5dCb0;\n    uint64 subscriptionId = 8293;\n    bytes32 public donId =\n        0x66756e2d6176616c616e6368652d66756a692d31000000000000000000000000;\n\n    string sourceGetResults =\n        \"const gameId = args[0];\"\n        \"const config = {\"\n        \"url: `https://api.sportsdata.io/v3/nba/stats/json/BoxScore/${gameId}?key=06b9feb762534274946d286934ff0235`\"\n        \"};\"\n        \"const response = await Functions.makeHttpRequest(config);\"\n        \"const match = response.data.Game;\"\n        \"if(match.IsClosed){\"\n        \"let encodedData = [];\"\n        \"encodedData.push(gameId);\"\n        \"encodedData.push(match.HomeTeamScore);\"\n        \"encodedData.push(match.AwayTeamScore);\"\n        \"return Functions.encodeString(JSON.stringify(encodedData))\"\n        \"}\"\n        \"else{\"\n        \"throw new Error('Match not found for given arguments')\"\n        \"}\";\n\n    /////////////////////////////////////////////\n    ////////// VARIABLES ////////////////////////\n    /////////////////////////////////////////////\n\n    uint256 private intervalForAutomation = 24 hours;\n    uint256 private lastTimestamp;\n\n    mapping(uint256 matchId => uint256[3]) s_Results;\n\n    constructor(address owner) ConfirmedOwner(owner) FunctionsClient(router) {}\n\n    /**\n     *\n     * @param betToClose Bet to check if is good or not\n     * @param pointsHome Points of home team\n     * @param pointsAway Points of away team\n     */\n\n    function _endBetsUsingMatchId(\n        uint256[] memory betToClose,\n        uint256 pointsHome,\n        uint256 pointsAway\n    ) external pure returns (bool ended, bool tipsterWon) {\n        for (uint i = 0; i < betToClose.length; i++) {\n            if (betToClose.length >= 2) {\n                if (betToClose[0] == 0 && betToClose[1] < 3) {\n                    if (\n                        (betToClose[1] == 0 && pointsHome <= pointsAway) ||\n                        (betToClose[1] == 1 && pointsHome >= pointsAway) ||\n                        (betToClose[1] == 2 && pointsHome != pointsAway)\n                    ) {\n                        tipsterWon = true;\n                    }\n                    ended = true;\n                } else if (\n                    betToClose.length >= 4 &&\n                    betToClose[0] == 1 &&\n                    betToClose[1] < 5 &&\n                    betToClose[2] < 3\n                ) {\n                    if (\n                        betToClose[1] == 0 &&\n                        ((betToClose[2] == 0 && pointsHome <= betToClose[3]) ||\n                            (betToClose[2] == 1 &&\n                                pointsHome >= betToClose[3]) ||\n                            (betToClose[2] == 2 && pointsHome != betToClose[3]))\n                    ) {\n                        tipsterWon = true;\n                    } else if (\n                        betToClose[1] == 1 &&\n                        ((betToClose[2] == 0 && pointsAway <= betToClose[3]) ||\n                            (betToClose[2] == 1 &&\n                                pointsAway >= betToClose[3]) ||\n                            (betToClose[2] == 2 && pointsAway != betToClose[3]))\n                    ) {\n                        tipsterWon = true;\n                    } else if (\n                        betToClose[1] == 2 &&\n                        ((betToClose[2] == 0 &&\n                            pointsAway + pointsHome <= betToClose[3]) ||\n                            (betToClose[2] == 1 &&\n                                pointsAway + pointsHome >= betToClose[3]) ||\n                            (betToClose[2] == 2 &&\n                                pointsAway + pointsHome != betToClose[3]))\n                    ) {\n                        tipsterWon = true;\n                    } else if (betToClose[1] == 3) {\n                        uint256 difference;\n                        if (int256(pointsAway) - int256(pointsHome) < 0) {\n                            difference = pointsHome - pointsAway;\n                        } else {\n                            difference = pointsAway - pointsHome;\n                        }\n                        if (\n                            (betToClose[2] == 0 &&\n                                difference <= betToClose[3]) ||\n                            (betToClose[2] == 1 &&\n                                difference >= betToClose[3]) ||\n                            (betToClose[2] == 2 && difference != betToClose[3])\n                        ) {\n                            tipsterWon = true;\n                        }\n                    } else if (\n                        betToClose[1] == 4 &&\n                        ((betToClose[2] == 0 &&\n                            (pointsAway <= betToClose[3] ||\n                                pointsHome <= betToClose[3])) ||\n                            (betToClose[2] == 1 &&\n                                (pointsAway >= betToClose[3] ||\n                                    pointsHome >= betToClose[3])) ||\n                            (betToClose[2] == 2 &&\n                                (pointsAway != betToClose[3] ||\n                                    pointsHome != betToClose[3])))\n                    ) {\n                        tipsterWon = true;\n                    }\n                    ended = true;\n                }\n            }\n        }\n    }\n\n    ///////////////////////////////////////////\n    ////// CHAINLINK FUNCTIONS ///////////////\n    ///////////////////////////////////////////\n\n    function endUsingMatchId(uint256 matchId_) public returns (bytes32) {\n        if (\n            block.timestamp < p2pBetting.getMatchTimestamp(matchId_) + 4 hours\n        ) {\n            revert P2PBetting__MatchDidNotEnd();\n        }\n        FunctionsRequest.Request memory req;\n        string[] memory args = new string[](1);\n        args[0] = uintToString(matchId_);\n        req.initializeRequestForInlineJavaScript(sourceGetResults);\n        if (args.length > 0) {\n            req.setArgs(args);\n        }\n        s_lastRequestId = _sendRequest(\n            req.encodeCBOR(),\n            subscriptionId,\n            gasLimit,\n            donId\n        );\n        return s_lastRequestId;\n    }\n\n    function uintToString(uint256 _value) public pure returns (string memory) {\n        if (_value == 0) {\n            return \"0\";\n        }\n        uint256 temp = _value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (_value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(_value % 10)));\n            _value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function fulfillRequest(\n        bytes32 requestId,\n        bytes memory response,\n        bytes memory err\n    ) internal override {\n        s_lastResponse = response;\n        s_lastError = err;\n        if (response.length > 64) {\n            uint256 offset = 0;\n            uint256 GameID;\n            assembly {\n                GameID := mload(add(response, add(offset, 0x20)))\n            }\n            offset += 32;\n            uint256 homePoints;\n            uint256 awayPoints;\n            assembly {\n                homePoints := mload(add(response, add(offset, 0x20)))\n            }\n            offset += 32;\n            assembly {\n                awayPoints := mload(add(response, add(offset, 0x20)))\n            }\n            s_Results[GameID][0] = homePoints;\n            s_Results[GameID][1] = awayPoints;\n            s_Results[GameID][2] = 1;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ////// CHAINLINK AUTOMATION ///////////////\n    ///////////////////////////////////////////\n\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory /*performData **/)\n    {\n        //Checkea si se ha de ejecutar la función.\n        if ((block.timestamp - lastTimestamp) >= intervalForAutomation) {\n            upkeepNeeded = true;\n        }\n    }\n\n    function performUpkeep(bytes calldata /*performData **/) external {\n        if ((block.timestamp - lastTimestamp) >= intervalForAutomation) {\n            p2pBetting.collectFees();\n        }\n    }\n\n    /////////////////////\n    // SETTERS //////////\n    /////////////////////\n\n    function setIntervalForAutomation(\n        uint256 _intervalForAutomation\n    ) external onlyOwner {\n        intervalForAutomation = _intervalForAutomation;\n    }\n\n    function setBettingFrontAddress(address bettingFront) external onlyOwner {\n        p2pBetting = P2PBetting(bettingFront);\n    }\n\n    /////////////////////\n    // GETTERS //////////\n    /////////////////////\n\n    function getResults(\n        uint256 matchId\n    ) external view returns (uint256[3] memory) {\n        return s_Results[matchId];\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AutomationBase.sol\";\nimport \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "src/P2PBettingFront.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"lib/BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol\";\nimport {P2PBettingActions} from \"../src/P2PBettingActions.sol\";\n\n//Alomejor hay que importar esta:\n// import {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\n\ncontract P2PBetting is Ownable {\n    P2PBettingActions p2pActions;\n\n    /////////////////////////////////////////////\n    ////////// ERRORS ///////////////////////////\n    /////////////////////////////////////////////\n\n    error P2PBetting__TransferFailed();\n    error P2PBetting__NumberOfChallengersCantBeZero();\n    error P2PBetting__MaxPriceCantBeZero();\n    error P2PBetting__MatchDoesntExist();\n    error P2PBetting__WrongBetFormat();\n    error P2PBetting__MatchDidNotEnd();\n    error P2PBetting__OddsMustBeHigherThanOne();\n    error P2PBetting__NotEnoughEthSent();\n    error P2PBetting__TooMuchEthSent();\n    error P2PBetting__BetIsFullOrNonexistent();\n    error P2PBetting__CantEnterBetNow();\n    error P2PBetting__UserNotInBet();\n    error P2PBetting__CantCallIfNotOwner();\n    error P2PBetting__AlreadyRetrievedOrBetNonexistent();\n    error P2PBetting__OnlyCalledIfTipsterLost();\n    error P2PBetting__UnexpectedRequestId();\n\n    /////////////////////////////////////////////\n    ////////// EVENTS ///////////////////////////\n    /////////////////////////////////////////////\n\n    event P2PBetting__NewFeeSet(uint256 indexed oldFee, uint256 indexed newFee);\n    event P2PBetting__NewOracleSet(address indexed oracle);\n    event P2PBetting__BetCreated(\n        uint256 indexed maxPrice,\n        uint256 indexed odds,\n        uint256 indexed maxNumOfPlayers,\n        uint256 betId\n    );\n    event P2PBetting__FeesCollected(uint256 indexed feesCollected);\n    event P2PBetting__BetJoined(\n        address indexed challenger,\n        uint256 indexed betID\n    );\n    event P2PBetting__RewardClaimed(\n        address indexed winner,\n        uint256 indexed amount\n    );\n\n    event P2PBetting__BetEnded(uint256 indexed betId, bool indexed tipsterWon);\n\n    event testevent(string name);\n\n    /////////////////////////////////////////////\n    ////////// VARIABLES ////////////////////////\n    /////////////////////////////////////////////\n\n    //Podría ser un array de estos, ya que puede haber EUR_ETH, ARG_ETH....\n    AggregatorV3Interface internal USD_ETH_dataFeed;\n\n    uint256 constant DECIMALS = 1000; //3 decimals\n    uint256 private s_fee; // 2000 = 2%\n    uint256 private feesCollected;\n\n    uint256 private numberOfBetsDone = 0;\n    uint256 private numberOfMatchesDone;\n\n    mapping(address user => Profile profile) s_Profiles;\n    mapping(uint256 betId => Bet bet) s_Bets;\n    mapping(uint256 matchId => Match) s_Matches;\n    uint256[] private allMatches;\n\n    struct Match {\n        uint256 matchId;\n        string home;\n        string away;\n        uint256 pointsHome;\n        uint256 pointsAway;\n        uint256 timeOfGame;\n        bool ended;\n        uint256[] betsOfMatch;\n    }\n\n    struct Profile {\n        int256 balanceVariation;\n        uint256[] betIdHistory;\n    }\n\n    struct Bet {\n        uint256 betId;\n        uint256 matchId;\n        address tipster;\n        uint256 collateralGiven;\n        uint256 moneyInBet;\n        uint256 maxNumberOfChallengers;\n        address[] challengers;\n        uint256[] challengersMoneyBet;\n        uint256 odds; //Por ejemplo 1500 = 1.5\n        uint256 maxEntryFee;\n        uint256 fee;\n        bool tipsterWon;\n        bool ended; //cuando el partido se acaba\n        uint256 startMatchTimestamp;\n        uint256[] betData;\n    }\n\n    /**\n     *\n     * @param fee_ Percentage of money collected as fee:\n     * @param owner Person who will manage the contract\n     */\n\n    constructor(uint256 fee_, address owner) Ownable(owner) {\n        s_fee = fee_ * DECIMALS;\n    }\n\n    /**\n     * Sends the fees collected to the owner of the contract\n     */\n\n    function collectFees() external {\n        uint256 feesCollectedNow = 0;\n        if (feesCollected != 0) {\n            feesCollectedNow = feesCollected;\n            feesCollected = 0;\n            (bool succ, ) = payable(owner()).call{value: feesCollectedNow}(\"\");\n            if (!succ) {\n                revert P2PBetting__TransferFailed();\n            }\n        }\n        emit P2PBetting__FeesCollected(feesCollectedNow);\n    }\n\n    /**\n     *\n     * @param matchId : ID of the match\n     * @param maxNumberOfChallengers_ : Number of max challengers Tipster allows\n     * @param odds_ : multiplier of the bet for challengers: 1500 if odds is 1.5\n     * @param maxEntryFee_ : Maximum money able to bet\n     * @param betData_ : [winner/points, home/away/sumatory/difference/both, more/less/equal, points]\n     */\n\n    function createBet(\n        uint256 matchId,\n        uint256 maxNumberOfChallengers_,\n        uint256 odds_,\n        uint256 maxEntryFee_,\n        uint256[] memory betData_\n    ) external payable {\n        if (odds_ <= 1000) {\n            revert P2PBetting__OddsMustBeHigherThanOne();\n        }\n        if (maxNumberOfChallengers_ == 0) {\n            revert P2PBetting__NumberOfChallengersCantBeZero();\n        }\n        if (maxEntryFee_ == 0) {\n            revert P2PBetting__MaxPriceCantBeZero();\n        }\n        if (s_Matches[matchId].timeOfGame == 0) {\n            revert P2PBetting__MatchDoesntExist();\n        }\n        if (betData_.length < 2) {\n            revert P2PBetting__WrongBetFormat();\n        }\n        if (\n            msg.value <\n            ((maxNumberOfChallengers_ * odds_ * maxEntryFee_) /\n                DECIMALS -\n                maxNumberOfChallengers_ *\n                maxEntryFee_)\n        ) {\n            revert P2PBetting__NotEnoughEthSent();\n        }\n        Bet memory newBet;\n        newBet.tipster = msg.sender;\n\n        newBet.maxNumberOfChallengers = maxNumberOfChallengers_;\n\n        newBet.odds = odds_;\n        newBet.fee = s_fee;\n        newBet.matchId = matchId;\n\n        newBet.maxEntryFee = maxEntryFee_;\n        newBet.betData = betData_;\n\n        newBet.moneyInBet = msg.value;\n        newBet.collateralGiven = msg.value;\n        newBet.betId = numberOfBetsDone;\n        newBet.startMatchTimestamp = s_Matches[matchId].timeOfGame;\n        s_Bets[numberOfBetsDone] = newBet;\n        s_Profiles[msg.sender].betIdHistory.push(numberOfBetsDone);\n        s_Profiles[msg.sender].balanceVariation -= int256(msg.value);\n        s_Matches[matchId].betsOfMatch.push(numberOfBetsDone);\n        numberOfBetsDone++;\n\n        emit P2PBetting__BetCreated(\n            maxEntryFee_,\n            odds_,\n            maxNumberOfChallengers_,\n            numberOfBetsDone - 1\n        );\n    }\n\n    /**\n     *\n     * @param betId_ Id of the bet you want to join\n     */\n\n    function joinBet(uint256 betId_) external payable {\n        Bet memory betSelected = s_Bets[betId_];\n        if (\n            betSelected.maxNumberOfChallengers <= betSelected.challengers.length\n        ) {\n            revert P2PBetting__BetIsFullOrNonexistent();\n        }\n        if (msg.value > betSelected.maxEntryFee) {\n            revert P2PBetting__TooMuchEthSent();\n        }\n\n        if (\n            betSelected.ended ||\n            block.timestamp + 10 minutes > betSelected.startMatchTimestamp //Se cierra 10 minutos antes del comienzo\n        ) {\n            revert P2PBetting__CantEnterBetNow();\n        }\n\n        s_Bets[betId_].challengers.push(msg.sender);\n        s_Bets[betId_].challengersMoneyBet.push(msg.value);\n        s_Bets[betId_].moneyInBet += msg.value;\n        s_Profiles[msg.sender].betIdHistory.push(betId_);\n        s_Profiles[msg.sender].balanceVariation -= int256(msg.value);\n\n        emit P2PBetting__BetJoined(msg.sender, betId_);\n    }\n\n    //Función automatizada que pide el resultado de fútbol a la api y\n    //cierra la apuesta, decidiendo si el ganador es el challenger o el tipster\n\n    //Ahora no tiene nada, solo está así para testear , cambiará en el futuro\n\n    /**\n     *\n     * @param matchId MatchID of the match that will get all its bets ended\n     */\n\n    function endMatch(uint256 matchId) external returns (bool) {\n        uint256[3] memory results = p2pActions.getResults(matchId);\n        if (results[2] == 1) {\n            Match memory auxMatch = s_Matches[matchId];\n            auxMatch.pointsHome = results[0];\n            auxMatch.pointsAway = results[1];\n            auxMatch.ended = true;\n            s_Matches[matchId] = auxMatch;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param matchId MatchID of the match that will get all its bets ended\n     */\n\n    function endBetsUsingMatchId(uint256 matchId) external onlyOwner {\n        if (!s_Matches[matchId].ended) {\n            revert P2PBetting__MatchDidNotEnd();\n        }\n        uint256[] memory bets = s_Matches[matchId].betsOfMatch;\n\n        for (uint i = 0; i < bets.length; i++) {\n            endBet(bets[i]);\n        }\n    }\n\n    /**\n     *\n     * @param betId MatchID of the match that will get all its bets ended\n     */\n\n    function endBet(uint256 betId) public {\n        Bet memory auxBet = s_Bets[betId];\n        Match memory auxMatch = s_Matches[auxBet.matchId];\n        uint256 pointsHome = auxMatch.pointsHome;\n        uint256 pointsAway = auxMatch.pointsAway;\n        (bool ended, bool tipsterWon) = p2pActions._endBetsUsingMatchId(\n            auxBet.betData,\n            pointsHome,\n            pointsAway\n        );\n        if (ended) {\n            auxBet.ended = ended;\n            if (tipsterWon) {\n                auxBet.tipsterWon = tipsterWon;\n            }\n            s_Bets[betId] = auxBet;\n            emit P2PBetting__BetEnded(betId, tipsterWon);\n        }\n    }\n\n    /**\n     *\n     * @param betId Id of the bet you want to get the rewards from\n     * @param numberOfChallenger Number of the position of your address in the challengers array\n     */\n\n    function getRewards(uint256 betId, uint256 numberOfChallenger) external {\n        Bet memory betSelected = s_Bets[betId];\n\n        if (\n            msg.sender == betSelected.tipster &&\n            betSelected.tipsterWon &&\n            betSelected.moneyInBet != 0 &&\n            betSelected.ended\n        ) {\n            s_Profiles[msg.sender].balanceVariation += int256(\n                betSelected.moneyInBet\n            );\n            uint256 feeFromThisBet = ((betSelected.moneyInBet -\n                betSelected.collateralGiven) *\n                betSelected.odds *\n                betSelected.fee) / (100 * DECIMALS * DECIMALS); //Revisar, puede que mal\n            uint256 moneyToTransfer = betSelected.moneyInBet - feeFromThisBet;\n            s_Bets[betId].moneyInBet = 0;\n            feesCollected += feeFromThisBet;\n            payable(msg.sender).transfer(moneyToTransfer);\n            emit P2PBetting__RewardClaimed(msg.sender, moneyToTransfer);\n        } else if (\n            numberOfChallenger < betSelected.challengers.length &&\n            msg.sender == betSelected.challengers[numberOfChallenger] &&\n            betSelected.challengersMoneyBet[numberOfChallenger] != 0 &&\n            betSelected.ended &&\n            !betSelected.tipsterWon\n        ) {\n            uint256 amountWon = (betSelected.odds *\n                betSelected.challengersMoneyBet[numberOfChallenger]) / DECIMALS;\n            s_Profiles[msg.sender].balanceVariation += int256(amountWon);\n            uint256 feeFromThisBet = (amountWon * betSelected.fee) /\n                (100 * DECIMALS); //Revisar, puede que mal\n            uint256 moneyToTransfer = amountWon - feeFromThisBet;\n            s_Bets[betId].challengersMoneyBet[numberOfChallenger] = 0;\n            feesCollected += feeFromThisBet;\n            payable(msg.sender).transfer(moneyToTransfer);\n            emit P2PBetting__RewardClaimed(msg.sender, moneyToTransfer);\n        } else {\n            revert P2PBetting__AlreadyRetrievedOrBetNonexistent();\n        }\n    }\n\n    /**\n     *\n     * @param betId_ Id of the bet that you want to get collateral from\n     * DOes not have to be called by tipster necessarily, but the money will go to him if\n     * challengers won but not all collateral was used because not all challengers bet the max possible.\n     */\n\n    function getCollateralBack(uint256 betId_) external {\n        Bet memory betSelected = s_Bets[betId_];\n        if (betSelected.collateralGiven == 0) {\n            revert P2PBetting__AlreadyRetrievedOrBetNonexistent();\n        }\n        if (!betSelected.ended || betSelected.tipsterWon) {\n            revert P2PBetting__OnlyCalledIfTipsterLost();\n        }\n        uint256 amountToTransferBack = betSelected.moneyInBet -\n            (((betSelected.moneyInBet - betSelected.collateralGiven) *\n                betSelected.odds) / DECIMALS);\n        s_Bets[betId_].collateralGiven = 0;\n        payable(betSelected.tipster).transfer(amountToTransferBack);\n    }\n\n    function endBetOwner(uint256 betId_, bool tipsterWon) external onlyOwner {\n        s_Bets[betId_].tipsterWon = tipsterWon;\n        s_Bets[betId_].ended = true;\n    }\n\n    ///////////////////////////////////////////\n    /////// TESTING ///////////////////////////\n    ///////////////////////////////////////////\n\n    function testingAddMatch(\n        uint256 gameId,\n        uint256 timestamp,\n        string memory home_,\n        string memory away_,\n        uint256 pointsHome_,\n        uint256 pointsAway_\n    ) external onlyOwner {\n        Match memory matchAux;\n        matchAux.matchId = gameId;\n        matchAux.timeOfGame = timestamp;\n        matchAux.home = home_;\n        matchAux.away = away_;\n        matchAux.pointsHome = pointsHome_;\n        matchAux.pointsAway = pointsAway_;\n        s_Matches[gameId] = matchAux;\n        allMatches.push(gameId);\n        numberOfMatchesDone++;\n    }\n\n    function testEndMatch(uint256 gameId) external onlyOwner {\n        s_Matches[gameId].ended = true;\n    }\n\n    ///////////////////////////////////////////\n    /////// SETTERS ///////////////////////////\n    ///////////////////////////////////////////\n\n    function setFee(uint256 newFee) external onlyOwner {\n        uint256 oldfee = s_fee;\n        s_fee = newFee;\n        emit P2PBetting__NewFeeSet(oldfee, newFee);\n    }\n\n    function setUsdOracle(address newOracle) external onlyOwner {\n        USD_ETH_dataFeed = AggregatorV3Interface(newOracle);\n        emit P2PBetting__NewOracleSet(newOracle);\n    }\n\n    function setBettingActionsContract(\n        address bettingAction\n    ) external onlyOwner {\n        p2pActions = P2PBettingActions(bettingAction);\n    }\n\n    ///////////////////////////////////////////\n    /////// GETTERS ///////////////////////////\n    ///////////////////////////////////////////\n\n    function getFee() external view returns (uint256) {\n        return s_fee;\n    }\n\n    function getOracle() external view returns (address) {\n        return address(USD_ETH_dataFeed);\n    }\n\n    function getProfile(address user) external view returns (Profile memory) {\n        return s_Profiles[user];\n    }\n\n    function getBet(uint256 betId) external view returns (Bet memory) {\n        return s_Bets[betId];\n    }\n\n    function getFeesCollected() external view returns (uint256) {\n        return feesCollected;\n    }\n\n    function getNumberOfChallenger(\n        uint256 betId_\n    ) external view returns (uint256) {\n        address[] memory possibleAddresses = s_Bets[betId_].challengers;\n        for (uint i; i < possibleAddresses.length; i++) {\n            if (possibleAddresses[i] == msg.sender) {\n                return i;\n            }\n        }\n        revert P2PBetting__UserNotInBet();\n    }\n\n    function getNumberOfBets() external view returns (uint256) {\n        return numberOfBetsDone;\n    }\n\n    //Uso de Chainlink-DataStreams\n    function getUsdConversionRate(\n        uint256 usdValue_\n    ) external view returns (uint256) {\n        (, int256 answer, , , ) = USD_ETH_dataFeed.latestRoundData();\n        uint256 ethPrice = uint256(answer * 10000000000);\n        // Convertir la cantidad de USD a Ether utilizando la tasa de conversión actual\n        uint256 ethAmount = (usdValue_ * 1e18) / ethPrice;\n        return ethAmount;\n    }\n\n    function getAllBets() external view returns (uint256[] memory) {\n        return allMatches;\n    }\n\n    function getNumberOfMatchesDone() external view returns (uint256) {\n        return numberOfMatchesDone;\n    }\n\n    function getMatch(uint256 matchId) external view returns (Match memory) {\n        return s_Matches[matchId];\n    }\n\n    function getMatchTimestamp(\n        uint256 matchId\n    ) external view returns (uint256) {\n        return s_Matches[matchId].timeOfGame;\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "lib/BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsSubscriptions} from \"../interfaces/IFunctionsSubscriptions.sol\";\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsSubscriptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Subscription interface.\ninterface IFunctionsSubscriptions {\n  struct Subscription {\n    uint96 balance; // ═════════╗ Common LINK balance that is controlled by the Router to be used for all consumer requests.\n    address owner; // ══════════╝ The owner can fund/withdraw/cancel the subscription.\n    uint96 blockedBalance; // ══╗ LINK balance that is reserved to pay for pending consumer requests.\n    address proposedOwner; // ══╝ For safely transferring sub ownership.\n    address[] consumers; // ════╸ Client contracts that can use the subscription\n    bytes32 flags; // ══════════╸ Per-subscription flags\n  }\n\n  struct Consumer {\n    bool allowed; // ══════════════╗ Owner can fund/withdraw/cancel the sub.\n    uint64 initiatedRequests; //   ║ The number of requests that have been started\n    uint64 completedRequests; // ══╝ The number of requests that have successfully completed or timed out\n  }\n\n  /// @notice Get details about a subscription.\n  /// @param subscriptionId - the ID of the subscription\n  /// @return subscription - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscription(uint64 subscriptionId) external view returns (Subscription memory);\n\n  /// @notice Retrieve details about multiple subscriptions using an inclusive range\n  /// @param subscriptionIdStart - the ID of the subscription to start the range at\n  /// @param subscriptionIdEnd - the ID of the subscription to end the range at\n  /// @return subscriptions - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscriptionsInRange(\n    uint64 subscriptionIdStart,\n    uint64 subscriptionIdEnd\n  ) external view returns (Subscription[] memory);\n\n  /// @notice Get details about a consumer of a subscription.\n  /// @param client - the consumer contract address\n  /// @param subscriptionId - the ID of the subscription\n  /// @return consumer - see IFunctionsSubscriptions.Consumer for more information on the structure\n  function getConsumer(address client, uint64 subscriptionId) external view returns (Consumer memory);\n\n  /// @notice Get details about the total amount of LINK within the system\n  /// @return totalBalance - total Juels of LINK held by the contract\n  function getTotalBalance() external view returns (uint96);\n\n  /// @notice Get details about the total number of subscription accounts\n  /// @return count - total number of subscriptions in the system\n  function getSubscriptionCount() external view returns (uint64);\n\n  /// @notice Time out all expired requests: unlocks funds and removes the ability for the request to be fulfilled\n  /// @param requestsToTimeoutByCommitment - A list of request commitments to time out\n  /// @dev The commitment can be found on the \"OracleRequest\" event created when sending the request.\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external;\n\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\n  /// @notice If amount is 0 the full balance will be withdrawn\n  /// @notice Both signing and transmitting wallets will have a balance to withdraw\n  /// @param recipient where to send the funds\n  /// @param amount amount to withdraw\n  function oracleWithdraw(address recipient, uint96 amount) external;\n\n  /// @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n  /// @dev Only callable by the Router Owner\n  /// @param subscriptionId subscription id\n  /// @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n  function ownerCancelSubscription(uint64 subscriptionId) external;\n\n  /// @notice Recover link sent with transfer instead of transferAndCall.\n  /// @dev Only callable by the Router Owner\n  /// @param to address to send link to\n  function recoverFunds(address to) external;\n\n  /// @notice Create a new subscription.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscription() external returns (uint64);\n\n  /// @notice Create a new subscription and add a consumer.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscriptionWithConsumer(address consumer) external returns (uint64 subscriptionId);\n\n  /// @notice Propose a new owner for a subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param newOwner - proposed new owner of the subscription\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external;\n\n  /// @notice Accept an ownership transfer.\n  /// @param subscriptionId - ID of the subscription\n  /// @dev will revert if original owner of subscriptionId has not requested that msg.sender become the new owner.\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external;\n\n  /// @notice Remove a consumer from a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - Consumer to remove from the subscription\n  function removeConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Add a consumer to a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - New consumer which can use the subscription\n  function addConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Cancel a subscription\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param to - Where to send the remaining LINK to\n  function cancelSubscription(uint64 subscriptionId, address to) external;\n\n  /// @notice Check to see if there exists a request commitment for all consumers for a given sub.\n  /// @param subscriptionId - ID of the subscription\n  /// @return true if there exists at least one unfulfilled request for the subscription, false otherwise.\n  /// @dev Looping is bounded to MAX_CONSUMERS*(number of DONs).\n  /// @dev Used to disable subscription canceling while outstanding request are present.\n  function pendingRequestExists(uint64 subscriptionId) external view returns (bool);\n\n  /// @notice Set subscription specific flags for a subscription.\n  /// Each byte of the flag is used to represent a resource tier that the subscription can utilize.\n  /// @param subscriptionId - ID of the subscription\n  /// @param flags - desired flag values\n  function setFlags(uint64 subscriptionId, bytes32 flags) external;\n\n  /// @notice Get flags for a given subscription.\n  /// @param subscriptionId - ID of the subscription\n  /// @return flags - current flag values\n  function getFlags(uint64 subscriptionId) external view returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "mode": "3",
      "details": null,
      "fallbackToOptimizingForSize": false,
      "disableSystemRequestMemoization": true
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "libraries": {},
    "isSystem": false,
    "forceEvmla": false,
    "areLibrariesMissing": false
  }
}